{
    "contents" : ".unlist <- function (x){\n  x1 <- x[[1L]]\n  if (is.factor(x1)){\n    structure(unlist(x), class = \"factor\", levels = levels(x1))\n  } else {\n    do.call(c, x)\n  }\n}\n#' Load and bin BAM file \n#' \n#' Load a BAM file and count reads in bins of size 50.000 base pairs\n#'\n#'@import sets\n#'@import Rsamtools\n#'@import S4Vectors\n#'@param bam_filepath Character The location and filename on the file system where the bam file is stored\n#'@param do_sort Boolean Sort the bam file? If the bam is unsorted set to true, \n#'but the use of pre-sorted bam files is recommended.\n#'@param separate_strands Boolean If set to true, reads from forward and reverse strands are counted and stored separately. \n#'This option should be used if you are planning on using regression, since this doubles the number of \n#'predictors (F+R) and distributes predictive power more equally over prediction sets since F and R \n#'strand from the same chromosome cannot be both in one prediction set. \n#'@param custom_name String The name of sample. Default samplename is the filename of the bam \n#'file without the .bam suffix and filepath prefix. \n#'@aliases nipt_sample\n#'\n#'@return Object NIPTSample\n#'\n#'@details\n#'This function returns an object of class NIPTSample, the main 'currency' of this package.\n#' It is a list with 5 items:\n#'\\itemize{\n#' \\item List \\strong{autosomal_chromosome_reads} Autosomal reads are stored in\n#' a matrix where the columns are the bins and rows (22) represent the autosomal\n#' chromosomes. The length of this list is either 1 or 2, depending if the \n#' forward and reverse reads are counted separately.\n#' \\item Character \\strong{correction_status_autosomal_chromosomes} The correction\n#' status of the autosomal reads. The status can either be \\emph{Uncorrected} or\n#' \\emph{GC Corrected} and/or \\emph{Chi Corrected}\n#' \\item List \\strong{sex_chromosome_reads} Sex chromosome reads are stored in a \n#' similar matrix(es) as the autosomal chromosome reads, now with 2 (X and Y) rows.\n#' \\item Character \\strong{correction_status_autosomal_chromosomes} The status can \n#' either be \\emph{Uncorrected} or \\emph{GC Corrected} and/or \\emph{Chi Corrected}.\n#' \\item Character \\strong{sample_name} Sample name \n#'}\n#'@export\nbin_bam_sample <- function(bam_filepath, do_sort=FALSE, separate_strands=FALSE, custom_name = NULL){\n  message(\"Loading Bam\")\n  if (!is.null(custom_name)){\n    name = custom_name\n  }\n  else{\n    name = basename(sub(\"^([^.]*).*\", \"\\\\1\", bam_filepath))\n  }\n  if (do_sort == TRUE){\n    temp <- sortBam(file = bam_filepath, destination = tempfile())\n    bam <- scanBam(file = temp)\n  }\n  else{\n    bam <- scanBam(bam_filepath)\n  }\n  message(\"BAM loaded\")\n  \n  chromos <- bam[[1]][3][[1]]\n  strands <- bam[[1]][4][[1]]\n  reads <- bam[[1]][5][[1]]\n  splitted_reads <- split(x = reads, f =  droplevels(strands[strands != \"*\"]))\n  splitted_chromos <- split(x = chromos, f = droplevels(strands[strands != \"*\"]))\n  binned_reads <- list()\n  message(\"Binning\")\n  binned_reads[[1]] <- bin_reads(reads_data_frame = splitted_reads[[1]], chroms = splitted_chromos[[1]])\n  binned_reads[[2]] <- bin_reads(reads_data_frame = splitted_reads[[2]], chroms = splitted_chromos[[2]])\n  message(\"Binning done\")\n  \n  if (separate_strands == FALSE){\n    binned_reads <- list(Reduce(\"+\", binned_reads))\n  }\n  \n  autosomal_reads <- lapply(X = binned_reads, FUN = splitchromosomes, chromosomes = autosomal_chromosomes)\n  sex_reads <- lapply(X = binned_reads, FUN = splitchromosomes, chromosomes = sex_chromosomes)\n  new_sample <- construct_sample(autosomal_reads = autosomal_reads, sex_reads = sex_reads, name = name, \n                                 correction_status_autosomal = Uncorrected, correction_status_sex = Uncorrected)\n  \n  return(new_sample)\n}\n\nbin_reads <- function(reads_data_frame, chroms){\n  n_bins <- getbins(max(reads_data_frame), bin_size)\n  bin <- matrix(data = 0, nrow = 0, ncol = n_bins , dimnames = list(NULL, 1:n_bins))\n  if ((length(unique(chroms[1:100]))) != 1){\n    stop(\"BAM file appears to be unsorted\", call. = F)\n  }\n  chromos <- rle(x = as.numeric(chroms))\n  min_read <- 0\n  max_read <- 1\n  for (chromo in 1:n_total_chromosomes){\n    max_read <- sum(chromos$lengths[1:(chromo)]) \n    \n    reads <- sapply(X = unique(reads_data_frame[min_read:max_read]),  \n                    FUN =  getbins, bin_size=bin_size)\n    min_read <- max_read +1\n    bins <- tabulate(reads, nbins = n_bins)\n    bin <- rbind(bin, bins)\n  }\n  return (bin)\n}\ngetbins <- function(pos, bin_size){\n  (pos-1) %/% bin_size + 1\n}",
    "created" : 1446131622000.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1481520563",
    "id" : "FB4B8BD1",
    "lastKnownWriteTime" : 1446200927,
    "path" : "~/NIPTeR/NIPTeR/R/bin_beta.R",
    "project_path" : "R/bin_beta.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}